'''

https://github.com/maxlabelle/WebMalwareScanner

Web Malware Scanner - A malware scanner for web installations
Copyright (c) 2012-2014, Maxime Labelle
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. All advertising materials mentioning features or use of this software
   must display the following acknowledgement:
   This product includes software developed by Maxime Labelle.
4. Neither the name of Web Malware Scanner nor the
   names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY MAXIME LABELLE ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL MAXIME LABELLE BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

'''

from __future__ import division
from cefpython3 import cefpython
from multiprocessing import Process, Queue
import wx
import time
import re
import urllib2
import uuid
import base64
import platform
import inspect
import struct
import sys
import os
import fnmatch
import stat
import json
import datetime
import mimetypes
import subprocess
import string
import hashlib
import math
import threading
import sqlite3
import yara

g_applicationSettings = None
g_browserSettings = None
g_commandLineSwitches = None

MATCHING_SIGNATURES = []
YARA_RULES = []
HASHTABLE = {}

SCANTHREADS = {}

DATABASE_FILENAME = 'wms.db'
DATABASE_SERVER_URL = 'https://raw.githubusercontent.com/maxlabelle/WebMalwareScanner/master/signatures/'
DATABASER_SERVER_FILENAME = 'database.json'
SIGNATURES_PATH = './signatures'
APPLICATION_OPTIONS = {}

def get_drives():
    if sys.platform == 'win32':
        from ctypes import windll
        drives = []
        bitmask = windll.kernel32.GetLogicalDrives()
        for letter in string.uppercase:
            if bitmask & 1:
                drives.append(letter)
            bitmask >>= 1

        return drives
    else:
        return ['/']
        
def isText(filename):
    s=open(filename).read(512)
    text_characters = "".join(map(chr, range(32, 127)) + list("\n\r\t\b"))
    _null_trans = string.maketrans("", "")
    if not s:
        # Empty files are considered text
        return True
    if "\0" in s:
        # Files with null bytes are likely binary
        return False
    # Get the non-text characters (maps a character to itself then
    # use the 'remove' option to get rid of the text characters.)
    t = s.translate(_null_trans, text_characters)
    # If more than 30% non-text characters, then
    # this is considered a binary file
    if float(len(t))/float(len(s)) > 0.30:
        return False
    return True

def GetApplicationPath(file=None):
    import re, os, platform
    if not hasattr(GetApplicationPath, "dir"):
        if hasattr(sys, "frozen"):
            dir = os.path.dirname(sys.executable)
        elif "__file__" in globals():
            dir = os.path.dirname(os.path.realpath(__file__))
        else:
            dir = os.getcwd()
        GetApplicationPath.dir = dir
    if file is None:
        file = ""
    if not file.startswith("/") and not file.startswith("\\") and (
            not re.search(r"^[\w-]+:", file)):
        path = GetApplicationPath.dir + os.sep + file
        if platform.system() == "Windows":
            path = re.sub(r"[/\\]+", re.escape(os.sep), path)
        path = re.sub(r"[/\\]+$", "", path)
        return path
    return str(file)

class ClientHandler:
    mainBrowser = None # May be None for global client callbacks.

    def __init__(self):
        pass

    statusMessageCount = 0
    def OnStatusMessage(self, browser, value):
        if not value:
            return
        self.statusMessageCount += 1
        if self.statusMessageCount > 3:
            return

    def OnKeyEvent(self, browser, event, eventHandle):
        if event["type"] == cefpython.KEYEVENT_KEYUP:
            return False
        '''
        linux = (platform.system() == "Linux")
        windows = (platform.system() == "Windows")
        if (linux and event["native_key_code"] == 71) \
                or (windows and event["windows_key_code"] == 116):
            browser.ReloadIgnoreCache()
            return True
        # Escape
        if (linux and event["native_key_code"] == 9) \
                or (windows and event["windows_key_code"] == 27):
            browser.StopLoad()
            return True
        # F12
        if (linux and event["native_key_code"] == 96) \
                or (windows and event["windows_key_code"] == 123):
            browser.ShowDevTools()
            return True
        '''
        return False

    def OnBeforeBrowse(self, browser, frame, request, isRedirect):
        if request.GetUrl().startswith("magnet:"):
            return True
        return False

    def GetAuthCredentials(self, browser, frame, isProxy, host, port, realm,
            scheme, callback):
        callback.Continue(username="test", password="test")
        return True

    def OnQuotaRequest(self, browser, originUrl, newSize, callback):
        callback.Continue(True)
        return True

    def GetCookieManager(self, browser, mainUrl):
        if not browser:
            return None
        cookieManager = browser.GetUserData("cookieManager")
        if cookieManager:
            return cookieManager
        else:
            cookieManager = cefpython.CookieManager.CreateManager("")
            if "cache_path" in g_applicationSettings:
                path = g_applicationSettings["cache_path"]
                cookieManager.SetStoragePath(path)
            browser.SetUserData("cookieManager", cookieManager)
            return cookieManager

    def OnProtocolExecution(self, browser, url, allowExecutionOut):
        if url.startswith("magnet:"):
            allowExecutionOut[0] = True

    def _OnBeforePluginLoad(self, browser, url, policyUrl, info):
        return False

    def _OnCertificateError(self, certError, requestUrl, callback):
        if requestUrl == "https://testssl-expire.disig.sk/index.en.html":
            return False
        if requestUrl \
                == "https://testssl-expire.disig.sk/index.en.html?allow=1":
            callback.Continue(True)
            return True
        return False

    def OnRendererProcessTerminated(self, browser, status):
        statuses = {
            cefpython.TS_ABNORMAL_TERMINATION: "TS_ABNORMAL_TERMINATION",
            cefpython.TS_PROCESS_WAS_KILLED: "TS_PROCESS_WAS_KILLED",
            cefpython.TS_PROCESS_CRASHED: "TS_PROCESS_CRASHED"
        }
        statusName = "Unknown"
        if status in statuses:
            statusName = statuses[status]

    def _Browser_LoadUrl(self, browser):
        if browser.GetUrl() == "data:text/html,Test#Browser.LoadUrl":
             browser.LoadUrl("file://"+GetApplicationPath("wxpython.html"))

    def OnLoadError(self, browser, frame, errorCode, errorTextList, failedUrl):
        if errorCode == cefpython.ERR_ABORTED:
            return;
        customErrorMessage = "My custom error message!"
        frame.LoadUrl("data:text/html,%s" % customErrorMessage)

    def OnBeforePopup(self, browser, frame, targetUrl, targetFrameName,
            popupFeatures, windowInfo, client, browserSettings,
            noJavascriptAccess):

        cefpython.PostTask(cefpython.TID_UI, self._CreatePopup, targetUrl)

        allowPopups = False
        return not allowPopups

    def _CreatePopup(self, url):
        frame = WMSMainFrame(url=url, popup=True)
        frame.Show()

class LoadDatabasesThread(threading.Thread):
    def __init__(self):
        threading.Thread.__init__(self)
        self.totalDatabases = 0
        self.loadedDatabases = 0
        self.signaturesStats = {}

    def downloadSignatureDatabase(self, fileName, folder):
        localFilePath = os.path.join(SIGNATURES_PATH, folder, fileName)
        fileData = urllib2.urlopen(DATABASE_SERVER_URL + folder + fileName).read()
        try:
            f = open(localFilePath,'w')
            f.write(fileData)
            f.close()
            return True
        except:
            return False

    def run(self):

        localdb = open(os.path.join(SIGNATURES_PATH, 'database.json')).read()
        LOCAL_DATABASE_FILE = json.loads(localdb)

        self.signaturesStats["DBVERSION"] = 'LATEST'
        self.signaturesStats["WMSVERSION"] = LOCAL_DATABASE_FILE["wms_version"]

        REMOTE_DATABASE_FILE = False

        PERFORM_DB_UPDATE = False

        try:
            remotedb = urllib2.urlopen(DATABASE_SERVER_URL + DATABASER_SERVER_FILENAME)
            REMOTE_DATABASE_FILE = json.loads(remotedb.read())
        except:
            self.signaturesStats["DBVERSION"] = 'UNKNOWN'
            self.signaturesStats["WMSVERSION"] = 'OUTDATED'

        if REMOTE_DATABASE_FILE and self.signaturesStats["DBVERSION"] != 'UNKNOWN' and LOCAL_DATABASE_FILE["signature_database_version"] != REMOTE_DATABASE_FILE["signature_database_version"]:
            self.signaturesStats["DBVERSION"] = 'OUTDATED'
            if APPLICATION_OPTIONS["AUTODBUPDATES"]:
                PERFORM_DB_UPDATE = True
            if LOCAL_DATABASE_FILE["wms_version"] != REMOTE_DATABASE_FILE["wms_version"]:
                self.signaturesStats["WMSVERSION"] = 'OUTDATED'

        if PERFORM_DB_UPDATE:
            print "Updating file"
            # loop in files, check if file exists, if not download

        for root, dirnames, filenames in os.walk(SIGNATURES_PATH):
            for filename in filenames:
                self.totalDatabases += 1

        for root, dirnames, filenames in os.walk(SIGNATURES_PATH+"/checksum/"):
            for filename in fnmatch.filter(filenames, '*.json'):
                try:
                    self.loadedDatabases += 1
                    dbdata = open(os.path.join(root, filename)).read()
                    # if PERFORM_DB_UPDATE:
                    # compare checksum with REMOTE_DATABASE_FILE if diff, download new
                    signatures = json.loads(dbdata)

                    for signatureHash in signatures["Database_Hash"]:
                        HASHTABLE[signatureHash["Malware_Hash"]] = signatureHash["Malware_Name"]
                except:
                    print "Unable to load signature file: " + filename
                    pass

        self.signaturesStats["MatchingSignatures"] = 0
        for root, dirnames, filenames in os.walk(SIGNATURES_PATH+"/rules/"):
            for filename in fnmatch.filter(filenames, '*.yar'):
                try:
                    self.loadedDatabases += 1
                    filepath = os.path.join(root, filename)
                    rules = yara.compile(filepath=filepath)
                    YARA_RULES.append(rules)
                    self.signaturesStats["MatchingSignatures"] += 1
                except:
                    print "Unable to load signature file: " + filename
                    pass

        self.signaturesStats["MD5Signatures"] = len(HASHTABLE)

        # if PERFORM_DB_UPDATE:
        # set DBVERSION = 'LATEST'

    def getProgress(self):
        if self.totalDatabases > 0:
            return ((self.loadedDatabases / self.totalDatabases) * 100)
        else:
            return 0

    def getSignaturesStats(self):
        return self.signaturesStats

class ScanThread(threading.Thread):
    def __init__(self, scanDetails):
        threading.Thread.__init__(self)
        self.scanDetails = scanDetails
        self.stopped = False
        self.totalInfected = 0
        self.totalInsecure = 0
        self.totalFiles = 0
        self.totalScanned = 0
        self.scanResults = []
        self.paused = False

        self.step = int(self.scanDetails["currentstep"])

    def run(self):
        self.localScan()

    def getCurrentStep(self):
        self.paused = True
        return str(self.step)

    def getTotalFiles(self):
        for root, dirnames, filenames in os.walk(self.scanDetails["path"]):
            for filename in filenames:
                self.totalFiles += 1
        return self.totalFiles

    def localScan(self):

        for root, dirnames, filenames in os.walk(self.scanDetails["path"]):
            for filename in filenames:
                if self.paused:
                    return

                self.totalScanned += 1

                if self.step > int(self.totalScanned):
                    time.sleep(0.01)
                    continue
                else:
                    self.step = self.totalScanned

                malware = False

                currentfile = os.path.join(root, filename)

                fileHandle = open(currentfile, 'rb')
                fileData = fileHandle.read()

                hash = hashlib.md5()
                hash.update(fileData)
                currentchecksum = hash.hexdigest()
                if currentchecksum in HASHTABLE:
                    malware = str(HASHTABLE[currentchecksum])
                    self.infectedFound(currentfile, malware)

                if isText(currentfile):
                    malware = ''
                    for rules in YARA_RULES:
                        if self.paused:
                            return
                        try:
                            result = rules.match(data=fileData)
                            if result:
                                for rule in result:
                                    self.infectedFound(currentfile, str(rule).replace("_", " "))
                        except:
                            pass

    def infectedFound(self, filename, malware):
        result = {
            'filename': filename,
            'malware': malware
        }
        self.scanResults.append(result)

    def getProgress(self):
        return ((self.step / self.totalFiles) * 100)

    def getScanResults(self):
        return self.scanResults

    def stop(self):
        self.stopped = True

class WMSMainFrame(wx.Frame):
    browser = None
    mainPanel = None
    currentPage = None
    mainFrame = None
    database = None
    databaseCursor = None
    signaturesStats = {}
    ScanTaskTimerID = 1
    LoadTaskTimerID = 2
    LoadingThread = False

    def GetHandleForBrowser(self):
        if self.mainPanel:
            return self.mainPanel.GetHandle()
        else:
            return self.GetHandle()

    def __init__(self, url=None, popup=False):
        title = "OWASP Web Malware Scanner"
        wx.Frame.__init__(self, parent=None, id=wx.ID_ANY,
                title=title)
        size=(800,400)

        # This is an optional code to enable High DPI support.
        if "auto_zooming" in g_applicationSettings \
                and g_applicationSettings["auto_zooming"] == "system_dpi":
            size = cefpython.DpiAware.CalculateWindowSize(size[0], size[1])

        self.SetSize(size)

        ico = wx.Icon('resources/images/owasp_logo.png', wx.BITMAP_TYPE_PNG)
        self.SetIcon(ico)

        # Global client callbacks must be set before browser is created.

        self.clientHandler = ClientHandler()
        '''
        cefpython.SetGlobalClientCallback("OnCertificateError",
                self.clientHandler._OnCertificateError)
        cefpython.SetGlobalClientCallback("OnBeforePluginLoad",
                self.clientHandler._OnBeforePluginLoad)
        cefpython.SetGlobalClientCallback("OnAfterCreated",
                self.clientHandler._OnAfterCreated)
        '''

        windowInfo = cefpython.WindowInfo()
        windowInfo.SetAsChild(self.GetHandleForBrowser())

        self.currentPage = 'loading'
        url = "file://"+GetApplicationPath("views/loading.html")
        self.browser = cefpython.CreateBrowserSync(windowInfo,
                browserSettings=g_browserSettings,
                navigateUrl=url)

        self.clientHandler.mainBrowser = self.browser
        self.browser.SetClientHandler(self.clientHandler)

        self.browser.SetClientCallback("OnLoadEnd", self.OnLoadEnd)

        self.jsBindings = cefpython.JavascriptBindings(
            bindToFrames=True, bindToPopups=True)

        self.jsBindings.SetFunction("WMSCoreNavigate", self.WMSCoreNavigate)
        self.jsBindings.SetFunction("WMSCoreMaximize", self.WMSCoreMaximize)
        self.jsBindings.SetFunction("WMSCoreListLocalFiles", self.WMSCoreListLocalFiles)
        self.jsBindings.SetFunction("WMSCoreStartLocalScan", self.WMSCoreStartLocalScan)
        self.jsBindings.SetFunction("WMSCoreUpdateScanResults", self.WMSCoreUpdateScanResults)
        self.jsBindings.SetFunction("WMSCoreUpdateScanList", self.WMSCoreUpdateScanList)
        self.jsBindings.SetFunction("WMSCoreViewScan", self.WMSCoreViewScan)
        self.jsBindings.SetFunction("WMSCoreGetScanDetails", self.WMSCoreGetScanDetails)
        self.jsBindings.SetFunction("WMSCoreDeleteScan", self.WMSCoreDeleteScan)
        self.jsBindings.SetFunction("WMSCorePauseScan", self.WMSCorePauseScan)
        self.jsBindings.SetFunction("WMSCoreResumeScan", self.WMSCoreResumeScan)
        self.jsBindings.SetFunction("WMSCoreGetScanProgress", self.WMSCoreGetScanProgress)
        self.jsBindings.SetFunction("WMSCoreUpdateSignaturesStats", self.WMSCoreUpdateSignaturesStats)
        self.jsBindings.SetFunction("WMSCoreGetSettingsOptions", self.WMSCoreGetSettingsOptions)
        self.jsBindings.SetFunction("WMSCoreSetSettingsOptions", self.WMSCoreSetSettingsOptions)
        self.jsBindings.SetFunction("WMSCoreGetSettingsUpdates", self.WMSCoreGetSettingsUpdates)

        '''
        jsBindings.SetFunction("PyPrint", PyPrint)
        jsBindings.SetProperty("pyProperty", "This was set in Python")
        jsBindings.SetProperty("pyConfig", ["This was set in Python",
                {"name": "Nested dictionary", "isNested": True},
                [1,"2", None]])
        '''

        self.browser.SetJavascriptBindings(self.jsBindings)

        #self.browser.ShowDevTools()

        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_SIZE, self.OnSize)
        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnLoadEnd(self, browser, frame, httpStatusCode):
        if self.currentPage == 'loading':
            self.WMSLoad()

        if self.currentPage == 'main':
            self.CreateScanTaskTimer()

    def OnSetFocus(self, event):
        cefpython.WindowUtils.OnSetFocus(self.GetHandleForBrowser(), 0, 0, 0)

    def OnSize(self, event):
        cefpython.WindowUtils.OnSize(self.GetHandleForBrowser(), 0, 0, 0)

    def OnClose(self, event):
        for threadName in SCANTHREADS.keys():
            if SCANTHREADS[threadName].isAlive():
                id_scan = threadName.replace("SCAN_", "")
                self.WMSCorePauseScan(id_scan, False)

        del self.clientHandler.mainBrowser
        del self.browser

        self.Destroy()

    def OnIdle(self, event):
        cefpython.MessageLoopWork()

    def WMSLoad(self):

        self.database = sqlite3.connect(DATABASE_FILENAME)
        self.database.row_factory = sqlite3.Row

        self.databaseCursor = self.database.cursor()
        self.databaseCursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='scans'")
        if not self.databaseCursor.fetchone():
            self.databaseCursor.execute("CREATE TABLE scans(id_scan INTEGER PRIMARY KEY AUTOINCREMENT, scandate TEXT, type TEXT, path TEXT, hostname TEXT, username TEXT, password TEXT, port TEXT, status TEXT, currentstep TEXT, scanprogress TEXT, infectedfound TEXT)")
            self.databaseCursor.execute("CREATE TABLE results(id_result INTEGER PRIMARY KEY AUTOINCREMENT, id_scan INTEGER, filename TEXT, malware TEXT)")
            self.databaseCursor.execute("CREATE TABLE options(option TEXT, value TEXT)")
            self.databaseCursor.execute("INSERT INTO options(option, value) VALUES('SCANMD5','TRUE')")
            self.databaseCursor.execute("INSERT INTO options(option, value) VALUES('SCANREGEXP','TRUE')")
            self.databaseCursor.execute("INSERT INTO options(option, value) VALUES('SCANBINARY','TRUE')")
            self.databaseCursor.execute("INSERT INTO options(option, value) VALUES('SCANCOMPRESSED','TRUE')")
            self.databaseCursor.execute("INSERT INTO options(option, value) VALUES('AUTODBUPDATES','TRUE')")
            self.database.commit()

        for row in self.databaseCursor.execute("SELECT * FROM options WHERE option LIKE 'AUTO%'"):
            APPLICATION_OPTIONS[row["option"]] = row["value"]

        self.LoadingThread = LoadDatabasesThread()
        self.LoadingThread.start()

        self.CreateLoadTaskTimer()

    def WMSCorePauseScan(self, id_scan, updateView = True):
        threadName = "SCAN_" + str(id_scan)
        currentstep = SCANTHREADS[threadName].getCurrentStep()
        self.databaseCursor.execute("UPDATE scans SET status='PAUSED', currentstep='"+str(currentstep)+"' WHERE id_scan=?", [id_scan])
        self.database.commit()

        if threadName in SCANTHREADS:
            if SCANTHREADS[threadName].isAlive():
                SCANTHREADS[threadName].stop()
            del SCANTHREADS[threadName]

        if updateView:
            self.WMSCoreGetScanDetails(id_scan)

    def WMSCoreUpdateSignaturesStats(self):
        stats = base64.b64encode(json.dumps(self.signaturesStats))
        self.browser.GetMainFrame().ExecuteJavascript("setSignaturesStats('"+str(stats)+"')")

    def WMSCoreResumeScan(self, id_scan):
        self.StartScanThread(id_scan)
        self.WMSCoreGetScanDetails(id_scan)

    def WMSCoreListLocalFiles(self, path = None):

        # list drives, folders
        # try/catch drivers sinon lecteur cd crash

        pathFolders = None
        if path:
            pathFolders = path.split('\\')

        jsTreeData = {'data':[]}

        drives = get_drives()

        for drive in drives:
            drivePath = drive + ":"
            treeObject = {
                'text': drivePath,
                'icon': 'glyphicon glyphicon-hdd',
                'state': {
                    'opened': True
                }
            }

            if path:
                if pathFolders[0] == drivePath:

                    treeObject["state"]["selected"] = True

                    def buildChildrens(parentindex, pathFolders):
                        children = []
                        currentPathFolder = ""
                        for index, folder in enumerate(pathFolders):
                            currentPathFolder = currentPathFolder + folder + "\\"

                            if index == parentindex:
                                dirs = []
                                try:
                                    dirs = os.listdir(currentPathFolder)
                                except WindowsError:
                                    print "[DIR LISTDIR ACCESS DENIED]"
                                for file in dirs:
                                    if not os.path.isdir(currentPathFolder+file):
                                        continue

                                    currentFolderObject = {
                                     'text': file.decode('latin-1').encode("utf-8").replace('"','\\"').replace("'","\\'"),
                                     'icon': 'glyphicon glyphicon-folder-open',
                                     'state': {
                                         'opened': True
                                     }
                                    }

                                    if ( index + 1 ) < len(pathFolders):
                                        if pathFolders[(index + 1)] == file:
                                            currentFolderObject["state"]["selected"] = True
                                            currentFolderObject["children"] = buildChildrens((index + 1), pathFolders)
                                    children.append(currentFolderObject)

                                return children

                    treeObject["children"] = []
                    currentPathFolder = ""
                    for index, folder in enumerate(pathFolders):
                        currentPathFolder = currentPathFolder + folder + "\\"

                        dirs = []
                        try:
                            dirs = os.listdir(currentPathFolder)
                        except WindowsError:
                            print "[DIR LISTDIR ACCESS DENIED]"

                        for file in dirs:
                            if not os.path.isdir(currentPathFolder+file):
                                continue

                            currentFolderObject = {
                             'text': file.decode('latin-1').encode("utf-8").replace('"','\\"').replace("'","\\'"),
                             'icon': 'glyphicon glyphicon-folder-open',
                             'state': {
                                 'opened': True
                             }
                            }

                            if ( index + 1 ) < len(pathFolders):
                                if pathFolders[(index + 1)] == file:
                                    currentFolderObject["state"]["selected"] = True
                                    currentFolderObject["children"] = buildChildrens((index + 1), pathFolders)

                            treeObject["children"].append(currentFolderObject)

                        break

            jsTreeData["data"].append(treeObject)

        self.browser.GetMainFrame().ExecuteJavascript("updateLocalFileTree('"+str(base64.b64encode(json.dumps(jsTreeData)))+"')")

    def WMSCoreStartLocalScan(self, LocalScanSelectedPath):
        '''
        scan status: PENDING, ACTIVE, DONE, PAUSED
        '''
        scandate = datetime.datetime.now()
        self.databaseCursor.execute("INSERT INTO scans(scandate, type, path, status, currentstep ) VALUES('"+scandate.strftime("%Y-%m-%d %H:%M:%S")+"','local',?,'PENDING', '1')", [str(LocalScanSelectedPath)])
        self.database.commit()
        self.WMSCoreUpdateScanList()
        self.WMSCoreNavigate('scanlist')

    def WMSCoreDeleteScan(self, id_scan):
        self.databaseCursor.execute("DELETE FROM scans WHERE id_scan=?", [id_scan])
        self.database.commit()
        self.databaseCursor.execute("DELETE FROM results WHERE id_scan=?", [id_scan])
        self.database.commit()
        threadName = "SCAN_" + str(id_scan)
        if threadName in SCANTHREADS:
            if SCANTHREADS[threadName].isAlive():
                SCANTHREADS[threadName].stop()
            del SCANTHREADS[threadName]
        self.WMSCoreUpdateScanList()

    def WMSCoreSetSettingsOptions(self, options):
        options = json.loads(base64.b64decode(options))
        for option in options:
            self.databaseCursor.execute("UPDATE options SET value=? WHERE option=?", [option["value"], option["option"]])
        self.database.commit()

    def WMSCoreGetSettingsOptions(self):
        rows = []
        for row in self.databaseCursor.execute("SELECT * FROM options WHERE option LIKE 'SCAN%'"):
            rows.append({
                'option': row["option"],
                'value': row["value"]
            })

        rows = base64.b64encode(json.dumps(rows))
        self.browser.GetMainFrame().ExecuteJavascript("UpdateSettingsOptions('"+str(rows)+"')")

    def WMSCoreGetSettingsUpdates(self):
        rows = []
        for row in self.databaseCursor.execute("SELECT * FROM options WHERE option LIKE 'AUTO%'"):
            rows.append({
                'option': row["option"],
                'value': row["value"]
            })

        rows = base64.b64encode(json.dumps(rows))
        self.browser.GetMainFrame().ExecuteJavascript("UpdateSettingsUpdates('"+str(rows)+"')")

    def WMSCoreGetScanDetails(self, id_scan):
        self.databaseCursor.execute("SELECT * FROM scans WHERE id_scan=?", [id_scan])
        row = self.databaseCursor.fetchone()
        scanDetails = {
            'id_scan': row["id_scan"],
            'scandate': row["scandate"],
            'type': row["type"],
            'path': row["path"],
            'hostname': row["hostname"],
            'username': row["username"],
            'password': row["password"],
            'port': row["port"],
            'infectedfound': row["infectedfound"],
            'scanprogress': row["scanprogress"],
            'status': row["status"]
        }
        #print scanDetails
        #sys.exit()
        scanDetails = base64.b64encode(json.dumps(scanDetails))
        self.browser.GetMainFrame().ExecuteJavascript("UpdateScanDetails('"+str(scanDetails)+"')")

    def WMSCoreUpdateScanResults(self, id_scan):
        rows = []
        for row in self.databaseCursor.execute("SELECT * FROM results WHERE id_scan=? ORDER BY filename ASC", [id_scan]):
            rows.append({
                'id_scan': row["id_scan"],
                'filename': row["filename"],
                'malware': row["malware"]
            })

        rows = base64.b64encode(json.dumps(rows))
        self.browser.GetMainFrame().ExecuteJavascript("UpdateScanResults('"+str(rows)+"')")

    def WMSCoreUpdateScanList(self):
        rows = []
        for row in self.databaseCursor.execute("SELECT * FROM scans ORDER BY scandate DESC"):
            rows.append({
                'id_scan': row["id_scan"],
                'scandate': row["scandate"],
                'type': row["type"],
                'path': row["path"],
                'hostname': row["hostname"],
                'username': row["username"],
                'password': row["password"],
                'port': row["port"],
                'scanprogress': row["scanprogress"],
                'status': row["status"]
            })

        rows = base64.b64encode(json.dumps(rows))
        self.browser.GetMainFrame().ExecuteJavascript("UpdateScanList('"+str(rows)+"')")

    def WMSCoreMaximize(self):
        self.Maximize(True)

    def WMSCoreViewScan(self, id_scan):
        print 'test'

    def WMSCoreGetScanProgress(self, id_scan):
        self.databaseCursor.execute("SELECT * FROM scans WHERE id_scan=?", [id_scan])
        scanDetails = self.databaseCursor.fetchone()
        if self.browser:
            self.browser.GetMainFrame().ExecuteJavascript("setProgressScan('"+str(scanDetails["scanprogress"])+"', '"+str(id_scan)+"')")

    def WMSCoreNavigate(self, page):
        self.currentPage = page
        url = "file://"+GetApplicationPath("views/"+str(page)+".html")
        self.browser.LoadUrl(url)

    def CreateLoadTaskTimer(self):
        self.LoadTaskTimer = wx.Timer(self, self.LoadTaskTimerID)
        self.LoadTaskTimer.Start(100)
        wx.EVT_TIMER(self, self.LoadTaskTimerID, self.OnLoadTaskTimer)

    def OnLoadTaskTimer(self, event):
        if self.LoadingThread.isAlive():
            progress = self.LoadingThread.getProgress()
            action = "Loading signatures..."
            self.browser.GetMainFrame().ExecuteJavascript("setProgress("+str(progress)+", '"+str(action)+"')")
        else:
            progress = 100
            action = "Loading main application..."
            self.browser.GetMainFrame().ExecuteJavascript("setProgress("+str(progress)+", '"+str(action)+"')")
            self.signaturesStats = self.LoadingThread.getSignaturesStats()
            self.LoadTaskTimer.Stop()
            del self.LoadTaskTimer
            del self.LoadingThread

    def CreateScanTaskTimer(self):
        self.ScanTaskTimer = wx.Timer(self, self.ScanTaskTimerID)
        self.ScanTaskTimer.Start(1000)
        wx.EVT_TIMER(self, self.ScanTaskTimerID, self.OnScanTaskTimer)

    def OnScanTaskTimer(self, event):
        for row in self.databaseCursor.execute("SELECT * FROM scans WHERE status='ACTIVE' ORDER BY scandate DESC"):
            threadName = "SCAN_"+str(row["id_scan"])
            if threadName not in SCANTHREADS:
                self.databaseCursor.execute("UPDATE scans SET status='PENDING' WHERE id_scan=?", [row["id_scan"]])
                self.database.commit()

        for row in self.databaseCursor.execute("SELECT * FROM scans WHERE status='PENDING' ORDER BY scandate DESC"):
            self.StartScanThread(row["id_scan"])

        for threadName in SCANTHREADS.keys():
            if SCANTHREADS[threadName].isAlive():
                progress = SCANTHREADS[threadName].getProgress()
                self.databaseCursor.execute("UPDATE scans SET scanprogress='"+str(progress)+"' WHERE id_scan=?", [threadName.replace("SCAN_", "")])
                self.database.commit()
            else:
                id_scan = int(threadName.replace("SCAN_", ""))
                scanResults = SCANTHREADS[threadName].getScanResults()
                #print scanResults
                #sys.exit()
                for result in scanResults:
                    self.databaseCursor.execute("INSERT INTO results(id_scan, filename, malware) VALUES(?,?,?)", [id_scan, str(result["filename"]), str(result["malware"])])
                    self.database.commit()

                infectedfound = 'no'
                if len(scanResults) > 0:
                    infectedfound = 'yes'

                self.WMSCoreGetScanDetails(id_scan)
                self.browser.GetMainFrame().ExecuteJavascript("setProgressScan('100')")

                self.databaseCursor.execute("UPDATE scans SET status='DONE', scanprogress='100', infectedfound='"+infectedfound+"' WHERE id_scan=?", [id_scan])
                self.database.commit()

                self.WMSCoreGetScanDetails(id_scan)
                self.WMSCoreUpdateScanResults(id_scan)
                self.WMSCoreUpdateScanList()
                del SCANTHREADS[threadName]

    def StartScanThread(self, id_scan):
        self.databaseCursor.execute("SELECT * FROM scans WHERE id_scan=?", [id_scan])
        scanDetails = self.databaseCursor.fetchone()

        threadName = "SCAN_"+str(id_scan)
        SCANTHREADS[threadName] = ScanThread(scanDetails)
        SCANTHREADS[threadName].start()
        scanDetails = SCANTHREADS[threadName].getTotalFiles()

        self.databaseCursor.execute("UPDATE scans SET status='ACTIVE' WHERE id_scan=?", [id_scan])
        self.database.commit()

        self.WMSCoreUpdateScanList()
        #print "===========TOTAL FILES:" + str(scanDetails)

    def testfromthread(self):
        print "======TEST FROM THREA======"

class WMS(wx.App):
    timer = None
    timerID = 1
    mainFrame = None

    def OnInit(self):
        self.CreateTimer()
        self.mainFrame = WMSMainFrame()
        self.SetTopWindow(self.mainFrame)
        self.mainFrame.Show()
        return True

    def CreateTimer(self):
        self.timer = wx.Timer(self, self.timerID)
        self.timer.Start(10) # 10ms
        wx.EVT_TIMER(self, self.timerID, self.OnTimer)

    def OnTimer(self, event):
        cefpython.MessageLoopWork()

def ExceptHook(excType, excValue, traceObject):
    import traceback, os, time, codecs
    # This hook does the following: in case of exception write it to
    # the "error.log" file, display it to the console, shutdown CEF
    # and exit application immediately by ignoring "finally" (os._exit()).
    errorMsg = "\n".join(traceback.format_exception(excType, excValue,
            traceObject))
    errorFile = GetApplicationPath("error.log")
    try:
        appEncoding = cefpython.g_applicationSettings["string_encoding"]
    except:
        appEncoding = "utf-8"
    if type(errorMsg) == bytes:
        errorMsg = errorMsg.decode(encoding=appEncoding, errors="replace")
    try:
        with codecs.open(errorFile, mode="a", encoding=appEncoding) as fp:
            fp.write("\n[%s] %s\n" % (
                    time.strftime("%Y-%m-%d %H:%M:%S"), errorMsg))
    except:
        print("[wxpython.py] WARNING: failed writing to error file: %s" % (
                errorFile))
    # Convert error message to ascii before printing, otherwise
    # you may get error like this:
    # | UnicodeEncodeError: 'charmap' codec can't encode characters
    errorMsg = errorMsg.encode("ascii", errors="replace")
    errorMsg = errorMsg.decode("ascii", errors="replace")
    print("\n"+errorMsg+"\n")
    cefpython.QuitMessageLoop()
    cefpython.Shutdown()
    os._exit(1)

if __name__ == '__main__':

        sys.excepthook = ExceptHook

        # Application settings
        g_applicationSettings = {

            # These directories must be set on Linux
            "locales_dir_path": cefpython.GetModuleDirectory()+"/locales",
            "resources_dir_path": cefpython.GetModuleDirectory(),
            "browser_subprocess_path": "%s/%s" % (
                cefpython.GetModuleDirectory(), "subprocess"),
            "unique_request_context_per_browser": True,
            "downloads_enabled": False,
            "debug": False,
            "background_color": 0,
            #"log_severity": cefpython.LOGSEVERITY_DISABLE,
            "log_severity": cefpython.LOGSEVERITY_INFO,
            "multi_threaded_message_loop": False,
            "remote_debugging_port": 60316,
            "context_menu": {
                "enabled": False,
                "navigation": False, # Back, Forward, Reload
                "print": False,
                "view_source": False,
                "external_browser": False, # Open in external browser
                "devtools": False, # Developer Tools
            },
            "ignore_certificate_errors": True,
        }

        g_browserSettings = {
            # "plugins_disabled": True,
            # "file_access_from_file_urls_allowed": True,
            # "universal_access_from_file_urls_allowed": True,
        }

        # Command line switches set programmatically
        g_commandLineSwitches = {
            # "proxy-server": "socks5://127.0.0.1:8888",
            # "no-proxy-server": "",
            # "enable-media-stream": "",
            # "disable-gpu": "",

        }

        cefpython.DpiAware.SetProcessDpiAware()

        cefpython.Initialize(g_applicationSettings, g_commandLineSwitches)

        app = WMS(False)
        app.MainLoop()

        # Let wx.App destructor do the cleanup before calling
        # cefpython.Shutdown(). This is to ensure reliable CEF shutdown.
        del app

        cefpython.Shutdown()
