'''

https://github.com/maxlabelle/WebMalwareScanner

Web Malware Scanner - A malware scanner for web installations
Copyright (c) 2012-2014, Maxime Labelle
All rights reserved.
Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. All advertising materials mentioning features or use of this software
   must display the following acknowledgement:
   This product includes software developed by Maxime Labelle.
4. Neither the name of Web Malware Scanner nor the
   names of its contributors may be used to endorse or promote products
   derived from this software without specific prior written permission.
THIS SOFTWARE IS PROVIDED BY MAXIME LABELLE ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL MAXIME LABELLE BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

'''

from __future__ import division
from cefpython3 import cefpython
from ctypes import windll
import wx
import time
import re
import uuid
import base64
import platform
import inspect
import struct
import sys
import os
import fnmatch
import stat
import json
import mimetypes
import subprocess
import string
import hashlib
import math
import threading
import sqlite3

g_applicationSettings = None
g_browserSettings = None
g_commandLineSwitches = None

JAVASCRIPT_SIGNATURES = []
PHP_SIGNATURES = []
HASH_SIGNATURES = []
HASHTABLE = {}

def get_drives():
    drives = []
    bitmask = windll.kernel32.GetLogicalDrives()
    for letter in string.uppercase:
        if bitmask & 1:
            drives.append(letter)
        bitmask >>= 1

    return drives

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def pmsg(msg, code = 'info'):
    colorcode = bcolors.OKGREEN
    if code == 'warning':
        colorcode = bcolors.WARNING
    if code == 'error':
        colorcode = bcolors.FAIL
    print bcolors.OKBLUE + bcolors.UNDERLINE + ">>" + bcolors.ENDC + " " + colorcode + msg + bcolors.ENDC

def GetApplicationPath(file=None):
    import re, os, platform
    # On Windows after downloading file and calling Browser.GoForward(),
    # current working directory is set to %UserProfile%.
    # Calling os.path.dirname(os.path.realpath(__file__))
    # returns for eg. "C:\Users\user\Downloads". A solution
    # is to cache path on first call.
    if not hasattr(GetApplicationPath, "dir"):
        if hasattr(sys, "frozen"):
            dir = os.path.dirname(sys.executable)
        elif "__file__" in globals():
            dir = os.path.dirname(os.path.realpath(__file__))
        else:
            dir = os.getcwd()
        GetApplicationPath.dir = dir
    # If file is None return current directory without trailing slash.
    if file is None:
        file = ""
    # Only when relative path.
    if not file.startswith("/") and not file.startswith("\\") and (
            not re.search(r"^[\w-]+:", file)):
        path = GetApplicationPath.dir + os.sep + file
        if platform.system() == "Windows":
            path = re.sub(r"[/\\]+", re.escape(os.sep), path)
        path = re.sub(r"[/\\]+$", "", path)
        return path
    return str(file)

'''
    def WMSLoad(self):
        print self.browserFrame.ExecuteJavascript("test();")

        jsBindings.SetFunction("PyPrint", PyPrint)
        jsBindings.SetProperty("pyProperty", "This was set in Python")
        jsBindings.SetProperty("pyConfig", ["This was set in Python",
                {"name": "Nested dictionary", "isNested": True},
                [1,"2", None]])

        SignaturesPath = 'signatures/'

        # Load signatures for PHP files
        totalDatabases = 0
        loadedDatabases = 0
        for root, dirnames, filenames in os.walk(SignaturesPath):
            for filename in filenames:
                totalDatabases += 1

        for root, dirnames, filenames in os.walk(SignaturesPath+"/php/"):
            for filename in fnmatch.filter(filenames, '*.json'):
                try:
                    signature = json.loads(open(os.path.join(root, filename)).read())
                    PHP_SIGNATURES.append(signature)
                    loadedDatabases += 1
                    progressBar(loadedDatabases, totalDatabases, "Loading signature database...")
                except IOError:
                    pmsg("Unable to load signature file: " + filename, "error")

        # Load signatures for Javscript files
        for root, dirnames, filenames in os.walk(SignaturesPath+"/js/"):
            for filename in fnmatch.filter(filenames, '*.json'):
                try:
                    signature = json.loads(open(os.path.join(root, filename)).read())
                    JAVASCRIPT_SIGNATURES.append(signature)
                    loadedDatabases += 1
                    progressBar(loadedDatabases, totalDatabases, "Loading signature database...")
                except IOError:
                    pmsg("Unable to load signature file: " + filename, "error")

        # Load signatures for MD5 hashes
        for root, dirnames, filenames in os.walk(SignaturesPath+"/checksum/"):
            for filename in fnmatch.filter(filenames, '*.json'):
                try:
                    signatures = json.loads(open(os.path.join(root, filename)).read())
                    HASH_SIGNATURES.append(signatures)
                    loadedDatabases += 1
                    progressBar(loadedDatabases, totalDatabases, "Loading signature database...")
                except IOError:
                    pmsg("Unable to load signature file: " + filename, "error")

        pmsg("Building hashtable...")
        for signature in HASH_SIGNATURES:
            for signatureHash in signature["Database_Hash"]:
                HASHTABLE[signatureHash["Malware_Hash"]] = signatureHash["Malware_Name"]
        pmsg("Loaded "+str(len(HASHTABLE))+" malware hash signatures.")

        size=(1024,768)
        self.SetSize(size)
        url = "file://"+GetApplicationPath("views/main.html")
        self.browser.LoadUrl(url)
    '''

class ClientHandler:
    mainBrowser = None # May be None for global client callbacks.

    def __init__(self):
        pass

    # -------------------------------------------------------------------------
    # DisplayHandler
    # -------------------------------------------------------------------------

    def OnAddressChange(self, browser, frame, url):
        print("[wxpython.py] DisplayHandler::OnAddressChange()")
        print("    url = %s" % url)

    def OnTitleChange(self, browser, title):
        print("[wxpython.py] DisplayHandler::OnTitleChange()")
        print("    title = %s" % title)

    def OnTooltip(self, browser, textOut):
        # OnTooltip not yet implemented (both Linux and Windows),
        # will be fixed in next CEF release, see Issue 783:
        # https://code.google.com/p/chromiumembedded/issues/detail?id=783
        print("[wxpython.py] DisplayHandler::OnTooltip()")
        print("    text = %s" % textOut[0])

    statusMessageCount = 0
    def OnStatusMessage(self, browser, value):
        if not value:
            # Do not notify in the console about empty statuses.
            return
        self.statusMessageCount += 1
        if self.statusMessageCount > 3:
            # Do not spam too much.
            return
        print("[wxpython.py] DisplayHandler::OnStatusMessage()")
        print("    value = %s" % value)

    def OnConsoleMessage(self, browser, message, source, line):
        print("[wxpython.py] DisplayHandler::OnConsoleMessage()")
        print("    message = %s" % message)
        print("    source = %s" % source)
        print("    line = %s" % line)

    # -------------------------------------------------------------------------
    # KeyboardHandler
    # -------------------------------------------------------------------------

    def OnPreKeyEvent(self, browser, event, eventHandle,
            isKeyboardShortcutOut):
        print("[wxpython.py] KeyboardHandler::OnPreKeyEvent()")

    def OnKeyEvent(self, browser, event, eventHandle):
        if event["type"] == cefpython.KEYEVENT_KEYUP:
            # OnKeyEvent is called twice for F5/Esc keys, with event
            # type KEYEVENT_RAWKEYDOWN and KEYEVENT_KEYUP.
            # Normal characters a-z should have KEYEVENT_CHAR.
            return False
        print("[wxpython.py] KeyboardHandler::OnKeyEvent()")
        print("    type=%s" % event["type"])
        print("    modifiers=%s" % event["modifiers"])
        print("    windows_key_code=%s" % event["windows_key_code"])
        print("    native_key_code=%s" % event["native_key_code"])
        print("    is_system_key=%s" % event["is_system_key"])
        print("    character=%s" % event["character"])
        print("    unmodified_character=%s" % event["unmodified_character"])
        print("    focus_on_editable_field=%s" \
                % event["focus_on_editable_field"])
        linux = (platform.system() == "Linux")
        windows = (platform.system() == "Windows")
        # F5
        if (linux and event["native_key_code"] == 71) \
                or (windows and event["windows_key_code"] == 116):
            print("[wxpython.py] F5 pressed, calling"
                    " browser.ReloadIgnoreCache()")
            browser.ReloadIgnoreCache()
            return True
        # Escape
        if (linux and event["native_key_code"] == 9) \
                or (windows and event["windows_key_code"] == 27):
            print("[wxpython.py] Esc pressed, calling browser.StopLoad()")
            browser.StopLoad()
            return True
        # F12
        if (linux and event["native_key_code"] == 96) \
                or (windows and event["windows_key_code"] == 123):
            print("[wxpython.py] F12 pressed, calling"
                    " browser.ShowDevTools()")
            browser.ShowDevTools()
            return True
        return False

    # -------------------------------------------------------------------------
    # RequestHandler
    # -------------------------------------------------------------------------

    def OnBeforeBrowse(self, browser, frame, request, isRedirect):
        print("[wxpython.py] RequestHandler::OnBeforeBrowse()")
        print("    url = %s" % request.GetUrl()[:100])
        # Handle "magnet:" links.
        if request.GetUrl().startswith("magnet:"):
            print("[wxpython.p] RequestHandler::OnBeforeBrowse(): "
                    "magnet link clicked, cancelling browse request")
            return True
        return False

    def OnBeforeResourceLoad(self, browser, frame, request):
        print("[wxpython.py] RequestHandler::OnBeforeResourceLoad()")
        print("    url = %s" % request.GetUrl()[:100])
        return False

    def OnResourceRedirect(self, browser, frame, oldUrl, newUrlOut):
        print("[wxpython.py] RequestHandler::OnResourceRedirect()")
        print("    old url = %s" % oldUrl[:100])
        print("    new url = %s" % newUrlOut[0][:100])

    def GetAuthCredentials(self, browser, frame, isProxy, host, port, realm,
            scheme, callback):
        # This callback is called on the IO thread, thus print messages
        # may not be visible.
        print("[wxpython.py] RequestHandler::GetAuthCredentials()")
        print("    host = %s" % host)
        print("    realm = %s" % realm)
        callback.Continue(username="test", password="test")
        return True

    def OnQuotaRequest(self, browser, originUrl, newSize, callback):
        print("[wxpython.py] RequestHandler::OnQuotaRequest()")
        print("    origin url = %s" % originUrl)
        print("    new size = %s" % newSize)
        callback.Continue(True)
        return True

    def GetCookieManager(self, browser, mainUrl):
        # Create unique cookie manager for each browser.
        # You must set the "unique_request_context_per_browser"
        # application setting to True for the cookie manager
        # to work.
        # Return None to have one global cookie manager for
        # all CEF browsers.
        if not browser:
            # The browser param may be empty in some exceptional
            # case, see docs.
            return None
        cookieManager = browser.GetUserData("cookieManager")
        if cookieManager:
            return cookieManager
        else:
            print("[wxpython.py] RequestHandler::GetCookieManager():"\
                    " created cookie manager")
            cookieManager = cefpython.CookieManager.CreateManager("")
            if "cache_path" in g_applicationSettings:
                path = g_applicationSettings["cache_path"]
                # path = os.path.join(path, "cookies_browser_{}".format(
                #     browser.GetIdentifier()))
                cookieManager.SetStoragePath(path)
            browser.SetUserData("cookieManager", cookieManager)
            return cookieManager

    def OnProtocolExecution(self, browser, url, allowExecutionOut):
        # There's no default implementation for OnProtocolExecution on Linux,
        # you have to make OS system call on your own. You probably also need
        # to use LoadHandler::OnLoadError() when implementing this on Linux.
        print("[wxpython.py] RequestHandler::OnProtocolExecution()")
        print("    url = %s" % url)
        if url.startswith("magnet:"):
            print("[wxpython.py] Magnet link allowed!")
            allowExecutionOut[0] = True

    def _OnBeforePluginLoad(self, browser, url, policyUrl, info):
        # This is a global callback set using SetGlobalClientCallback().
        # Plugins are loaded on demand, only when website requires it,
        # the same plugin may be called multiple times.
        # This callback is called on the IO thread, thus print messages
        # may not be visible.
        print("[wxpython.py] RequestHandler::_OnBeforePluginLoad()")
        print("    url = %s" % url)
        print("    policy url = %s" % policyUrl)
        print("    info.GetName() = %s" % info.GetName())
        print("    info.GetPath() = %s" % info.GetPath())
        print("    info.GetVersion() = %s" % info.GetVersion())
        print("    info.GetDescription() = %s" % info.GetDescription())
        # False to allow, True to block plugin.
        return False

    def _OnCertificateError(self, certError, requestUrl, callback):
        # This is a global callback set using SetGlobalClientCallback().
        print("[wxpython.py] RequestHandler::_OnCertificateError()")
        print("    certError = %s" % certError)
        print("    requestUrl = %s" % requestUrl)
        if requestUrl == "https://testssl-expire.disig.sk/index.en.html":
            print("    Not allowed!")
            return False
        if requestUrl \
                == "https://testssl-expire.disig.sk/index.en.html?allow=1":
            print("    Allowed!")
            callback.Continue(True)
            return True
        return False

    def OnRendererProcessTerminated(self, browser, status):
        print("[wxpython.py] RequestHandler::OnRendererProcessTerminated()")
        statuses = {
            cefpython.TS_ABNORMAL_TERMINATION: "TS_ABNORMAL_TERMINATION",
            cefpython.TS_PROCESS_WAS_KILLED: "TS_PROCESS_WAS_KILLED",
            cefpython.TS_PROCESS_CRASHED: "TS_PROCESS_CRASHED"
        }
        statusName = "Unknown"
        if status in statuses:
            statusName = statuses[status]
        print("    status = %s" % statusName)

    def OnPluginCrashed(self, browser, pluginPath):
        print("[wxpython.py] RequestHandler::OnPluginCrashed()")
        print("    plugin path = %s" % pluginPath)

    # -------------------------------------------------------------------------
    # LoadHandler
    # -------------------------------------------------------------------------

    def OnLoadingStateChange(self, browser, isLoading, canGoBack,
            canGoForward):
        print("[wxpython.py] LoadHandler::OnLoadingStateChange()")
        print("    isLoading = %s, canGoBack = %s, canGoForward = %s" \
                % (isLoading, canGoBack, canGoForward))

    def OnLoadStart(self, browser, frame):
        print("[wxpython.py] LoadHandler::OnLoadStart()")
        print("    frame url = %s" % frame.GetUrl()[:100])

    def OnLoadEnd(self, browser, frame, httpStatusCode):
        print("[wxpython.py] LoadHandler::OnLoadEnd()")
        print("    frame url = %s" % frame.GetUrl()[:100])
        # For file:// urls the status code = 0
        print("    http status code = %s" % httpStatusCode)
        # Tests for the Browser object methods

    def _Browser_LoadUrl(self, browser):
        if browser.GetUrl() == "data:text/html,Test#Browser.LoadUrl":
             browser.LoadUrl("file://"+GetApplicationPath("wxpython.html"))

    def OnLoadError(self, browser, frame, errorCode, errorTextList, failedUrl):
        print("[wxpython.py] LoadHandler::OnLoadError()")
        print("    frame url = %s" % frame.GetUrl()[:100])
        print("    error code = %s" % errorCode)
        print("    error text = %s" % errorTextList[0])
        print("    failed url = %s" % failedUrl)
        # Handle ERR_ABORTED error code, to handle the following cases:
        # 1. Esc key was pressed which calls browser.StopLoad() in OnKeyEvent
        # 2. Download of a file was aborted
        # 3. Certificate error
        if errorCode == cefpython.ERR_ABORTED:
            print("[wxpython.py] LoadHandler::OnLoadError(): Ignoring load "
                    "error: Esc was pressed or file download was aborted, "
                    "or there was certificate error")
            return;
        customErrorMessage = "My custom error message!"
        frame.LoadUrl("data:text/html,%s" % customErrorMessage)

    # -------------------------------------------------------------------------
    # LifespanHandler
    # -------------------------------------------------------------------------

    # ** This callback is executed on the IO thread **
    # Empty place-holders: popupFeatures, client.
    def OnBeforePopup(self, browser, frame, targetUrl, targetFrameName,
            popupFeatures, windowInfo, client, browserSettings,
            noJavascriptAccess):
        print("[wxpython.py] LifespanHandler::OnBeforePopup()")
        print("    targetUrl = %s" % targetUrl)

        # Custom browser settings for popups:
        # > browserSettings[0] = {"plugins_disabled": True}

        # Set WindowInfo object:
        # > windowInfo[0] = cefpython.WindowInfo()

        # On Windows there are keyboard problems in popups, when popup
        # is created using "window.open" or "target=blank". This issue
        # occurs only in wxPython. PyGTK or PyQt do not require this fix.
        # The solution is to create window explicitilly, and not depend
        # on CEF to create window internally. See Issue 80 for details:
        # https://code.google.com/p/cefpython/issues/detail?id=80

        # If you set allowPopups=True then CEF will create popup window.
        # The wx.Frame cannot be created here, as this callback is
        # executed on the IO thread. Window should be created on the UI
        # thread. One solution is to call cefpython.CreateBrowser()
        # which runs asynchronously and can be called on any thread.
        # The other solution is to post a task on the UI thread, so
        # that cefpython.CreateBrowserSync() can be used.

        # Note that if you return True and create the popup window yourself,
        # then the popup window and parent window will not be able to script
        # each other. There will be no "window.opener" property available
        # in the popup window.

        cefpython.PostTask(cefpython.TID_UI, self._CreatePopup, targetUrl)

        allowPopups = False
        return not allowPopups

    def _CreatePopup(self, url):
        frame = MainFrame(url=url, popup=True)
        frame.Show()

    def _OnAfterCreated(self, browser):
        # This is a global callback set using SetGlobalClientCallback().
        print("[wxpython.py] LifespanHandler::_OnAfterCreated()")
        print("    browserId=%s" % browser.GetIdentifier())

    def RunModal(self, browser):
        print("[wxpython.py] LifespanHandler::RunModal()")
        print("    browserId=%s" % browser.GetIdentifier())

    def DoClose(self, browser):
        print("[wxpython.py] LifespanHandler::DoClose()")
        print("    browserId=%s" % browser.GetIdentifier())

    def OnBeforeClose(self, browser):
        print("[wxpython.py] LifespanHandler::OnBeforeClose")
        print("    browserId=%s" % browser.GetIdentifier())

    # -------------------------------------------------------------------------
    # JavascriptDialogHandler
    # -------------------------------------------------------------------------

    def OnJavascriptDialog(self, browser, originUrl, acceptLang, dialogType,
                   messageText, defaultPromptText, callback,
                   suppressMessage):
        print("[wxpython.py] JavascriptDialogHandler::OnJavascriptDialog()")
        print("    originUrl="+originUrl)
        print("    acceptLang="+acceptLang)
        print("    dialogType="+str(dialogType))
        print("    messageText="+messageText)
        print("    defaultPromptText="+defaultPromptText)
        # If you want to suppress the javascript dialog:
        # suppressMessage[0] = True
        return False

    def OnBeforeUnloadJavascriptDialog(self, browser, messageText, isReload,
            callback):
        print("[wxpython.py] OnBeforeUnloadJavascriptDialog()")
        print("    messageText="+messageText)
        print("    isReload="+str(isReload))
        # Return True if the application will use a custom dialog:
        #   callback.Continue(allow=True, userInput="")
        #   return True
        return False

    def OnResetJavascriptDialogState(self, browser):
        print("[wxpython.py] OnResetDialogState()")

    def OnJavascriptDialogClosed(self, browser):
        print("[wxpython.py] OnDialogClosed()")

class WMSMainFrame(wx.Frame):
    browser = None
    mainPanel = None
    currentPage = None
    mainFrame = None
    database = None
    databaseFile = 'wms.db'

    def GetHandleForBrowser(self):
        if self.mainPanel:
            return self.mainPanel.GetHandle()
        else:
            return self.GetHandle()

    def __init__(self, url=None, popup=False):
        title = "OWASP Web Malware Scanner"
        wx.Frame.__init__(self, parent=None, id=wx.ID_ANY,
                title=title)
        size=(800,400)

        # This is an optional code to enable High DPI support.
        if "auto_zooming" in g_applicationSettings \
                and g_applicationSettings["auto_zooming"] == "system_dpi":
            size = cefpython.DpiAware.CalculateWindowSize(size[0], size[1])

        self.SetSize(size)

        ico = wx.Icon('resources/images/owasp_logo.png', wx.BITMAP_TYPE_PNG)
        self.SetIcon(ico)

        url = "file://"+GetApplicationPath("views/loading.html")

        self.currentPage = 'loading'

        # Global client callbacks must be set before browser is created.

        self.clientHandler = ClientHandler()

        cefpython.SetGlobalClientCallback("OnCertificateError",
                self.clientHandler._OnCertificateError)
        cefpython.SetGlobalClientCallback("OnBeforePluginLoad",
                self.clientHandler._OnBeforePluginLoad)
        cefpython.SetGlobalClientCallback("OnAfterCreated",
                self.clientHandler._OnAfterCreated)

        windowInfo = cefpython.WindowInfo()
        windowInfo.SetAsChild(self.GetHandleForBrowser())
        self.browser = cefpython.CreateBrowserSync(windowInfo,
                browserSettings=g_browserSettings,
                navigateUrl=url)

        self.clientHandler.mainBrowser = self.browser
        self.browser.SetClientHandler(self.clientHandler)

        self.browser.SetClientCallback("OnLoadEnd", self.OnLoadEnd)

        self.jsBindings = cefpython.JavascriptBindings(
            bindToFrames=True, bindToPopups=True)

        self.jsBindings.SetFunction("WMSCoreNavigate", self.WMSCoreNavigate)
        self.jsBindings.SetFunction("WMSCoreMaximize", self.WMSCoreMaximize)
        self.jsBindings.SetFunction("WMSCoreListLocalFiles", self.WMSCoreListLocalFiles)
        self.jsBindings.SetFunction("WMSCoreStartLocalScan", self.WMSCoreStartLocalScan)

        '''
        jsBindings.SetFunction("PyPrint", PyPrint)
        jsBindings.SetProperty("pyProperty", "This was set in Python")
        jsBindings.SetProperty("pyConfig", ["This was set in Python",
                {"name": "Nested dictionary", "isNested": True},
                [1,"2", None]])
        '''
        self.browser.SetJavascriptBindings(self.jsBindings)

        self.Bind(wx.EVT_SET_FOCUS, self.OnSetFocus)
        self.Bind(wx.EVT_SIZE, self.OnSize)

        self.Bind(wx.EVT_CLOSE, self.OnClose)

    def OnLoadEnd(self, browser, frame, httpStatusCode):
        if self.currentPage == 'loading':
            self.WMSLoad()

        if self.currentPage == 'main':
            print "eh"

    def OnSetFocus(self, event):
        cefpython.WindowUtils.OnSetFocus(self.GetHandleForBrowser(), 0, 0, 0)

    def OnSize(self, event):
        cefpython.WindowUtils.OnSize(self.GetHandleForBrowser(), 0, 0, 0)

    def OnClose(self, event):
        del self.clientHandler.mainBrowser
        del self.browser

        self.Destroy()

    def OnIdle(self, event):
        cefpython.MessageLoopWork()

    def GUISetProgress(self, current, total, action):
        i = (current / total) * 100
        if i > 100:
            i = 100
        if i < 0:
            i = 0

        self.browser.GetMainFrame().ExecuteFunction("setProgress("+str(i)+", '"+str(action)+"')")

    def WMSLoad(self):

        self.database = sqlite3.connect(self.databaseFile)

        self.databaseCursor = self.database.cursor()
        self.databaseCursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='scans'")
        if not self.databaseCursor.fetchone():
            self.databaseCursor.execute("CREATE TABLE scans(id_scan INTEGER PRIMARY KEY AUTOINCREMENT, scandate TEXT, type TEXT, path TEXT, hostname TEXT, username TEXT, password TEXT, port TEXT, status TEXT)")
            self.database.commit()

        SignaturesPath = './signatures/'

        # Load signatures for PHP files
        totalDatabases = 0
        loadedDatabases = 0
        for root, dirnames, filenames in os.walk(SignaturesPath):
            for filename in filenames:
                totalDatabases += 1

        for root, dirnames, filenames in os.walk(SignaturesPath+"/php/"):
            for filename in fnmatch.filter(filenames, '*.json'):
                try:
                    signature = json.loads(open(os.path.join(root, filename)).read())
                    PHP_SIGNATURES.append(signature)
                    loadedDatabases += 1
                    self.GUISetProgress(loadedDatabases, totalDatabases, "Loading php signature database...")
                except IOError:
                    pmsg("Unable to load signature file: " + filename, "error")

        # Load signatures for Javscript files
        for root, dirnames, filenames in os.walk(SignaturesPath+"/js/"):
            for filename in fnmatch.filter(filenames, '*.json'):
                try:
                    signature = json.loads(open(os.path.join(root, filename)).read())
                    JAVASCRIPT_SIGNATURES.append(signature)
                    loadedDatabases += 1
                    self.GUISetProgress(loadedDatabases, totalDatabases, "Loading javascript signature database...")
                except IOError:
                    pmsg("Unable to load signature file: " + filename, "error")

        # Load signatures for MD5 hashes
        for root, dirnames, filenames in os.walk(SignaturesPath+"/checksum/"):
            for filename in fnmatch.filter(filenames, '*.json'):
                try:
                    signatures = json.loads(open(os.path.join(root, filename)).read())
                    HASH_SIGNATURES.append(signatures)
                    loadedDatabases += 1
                    self.GUISetProgress(loadedDatabases, totalDatabases, "Loading checksum database...")
                except IOError:
                    pmsg("Unable to load signature file: " + filename, "error")

        pmsg("Building hashtable...")
        for signature in HASH_SIGNATURES:
            for signatureHash in signature["Database_Hash"]:
                HASHTABLE[signatureHash["Malware_Hash"]] = signatureHash["Malware_Name"]
        pmsg("Loaded "+str(len(HASHTABLE))+" malware hash signatures.")

        self.WMSCoreListLocalFiles()

        self.GUISetProgress(100,100,"Loading hashtable...")

    def WMSCoreListLocalFiles(self, path = None):

        # list drives, folders
        # try/catch drivers sinon lecteur cd crash

        pathFolders = None
        if path:
            pathFolders = path.split('\\')

        jsTreeData = {'data':[]}

        drives = get_drives()

        for drive in drives:
            drivePath = drive + ":"
            treeObject = {
                'text': drivePath,
                'icon': 'glyphicon glyphicon-hdd',
                'state': {
                    'opened': True
                }
            }

            if path:
                if pathFolders[0] == drivePath:

                    treeObject["state"]["selected"] = True

                    def buildChildrens(parentindex, pathFolders):
                        children = []
                        currentPathFolder = ""
                        for index, folder in enumerate(pathFolders):
                            currentPathFolder = currentPathFolder + folder + "\\"

                            if index == parentindex:
                                dirs = []
                                try:
                                    dirs = os.listdir(currentPathFolder)
                                except WindowsError:
                                    print "[DIR LISTDIR ACCESS DENIED]"
                                for file in dirs:
                                    if not os.path.isdir(currentPathFolder+file):
                                        continue

                                    currentFolderObject = {
                                     'text': file.decode('latin-1').encode("utf-8").replace('"','\\"').replace("'","\\'"),
                                     'icon': 'glyphicon glyphicon-folder-open',
                                     'state': {
                                         'opened': True
                                     }
                                    }

                                    if ( index + 1 ) < len(pathFolders):
                                        if pathFolders[(index + 1)] == file:
                                            currentFolderObject["state"]["selected"] = True
                                            currentFolderObject["children"] = buildChildrens((index + 1), pathFolders)
                                    children.append(currentFolderObject)

                                return children

                    treeObject["children"] = []
                    currentPathFolder = ""
                    for index, folder in enumerate(pathFolders):
                        currentPathFolder = currentPathFolder + folder + "\\"

                        dirs = []
                        try:
                            dirs = os.listdir(currentPathFolder)
                        except WindowsError:
                            print "[DIR LISTDIR ACCESS DENIED]"

                        for file in dirs:
                            if not os.path.isdir(currentPathFolder+file):
                                continue

                            currentFolderObject = {
                             'text': file.decode('latin-1').encode("utf-8").replace('"','\\"').replace("'","\\'"),
                             'icon': 'glyphicon glyphicon-folder-open',
                             'state': {
                                 'opened': True
                             }
                            }

                            if ( index + 1 ) < len(pathFolders):
                                if pathFolders[(index + 1)] == file:
                                    currentFolderObject["state"]["selected"] = True
                                    currentFolderObject["children"] = buildChildrens((index + 1), pathFolders)

                            treeObject["children"].append(currentFolderObject)

                        break

            jsTreeData["data"].append(treeObject)

        try:
            self.browser.GetMainFrame().ExecuteFunction("updateLocalFileTree('"+str(base64.b64encode(json.dumps(jsTreeData)))+"')")
        except ValueError:
            print "[ERROR ExecuteFunction @ updateLocalFileTree() ]"

    def WMSCoreStartLocalScan(self, LocalScanSelectedPath):
        print LocalScanSelectedPath

    def WMSCoreStartRemoteScan(self):
        # scp wms.py host:/tmp, python /tmp/wms.py
        # wms.py write to /tmp/wms_data.json
        # scp get /tmp/wms_data.json timer
        # use /tmp/wms_data.json to track progress/results
        print 'ok'

    def WMSCoreMaximize(self):
        self.Maximize(True)

    def WMSCoreNavigate(self, page):
        self.currentPage = page
        url = "file://"+GetApplicationPath("views/"+str(page)+".html")
        self.browser.LoadUrl(url)

class WMS(wx.App):
    timer = None
    timerID = 1
    mainFrame = None

    def OnInit(self):
        self.CreateTimer()
        self.mainFrame = WMSMainFrame()
        self.SetTopWindow(self.mainFrame)
        self.mainFrame.Show()
        return True

    def CreateTimer(self):
        self.timer = wx.Timer(self, self.timerID)
        self.timer.Start(10) # 10ms
        wx.EVT_TIMER(self, self.timerID, self.OnTimer)

    def OnTimer(self, event):
        cefpython.MessageLoopWork()

def ExceptHook(excType, excValue, traceObject):
    import traceback, os, time, codecs
    # This hook does the following: in case of exception write it to
    # the "error.log" file, display it to the console, shutdown CEF
    # and exit application immediately by ignoring "finally" (os._exit()).
    errorMsg = "\n".join(traceback.format_exception(excType, excValue,
            traceObject))
    errorFile = GetApplicationPath("error.log")
    try:
        appEncoding = cefpython.g_applicationSettings["string_encoding"]
    except:
        appEncoding = "utf-8"
    if type(errorMsg) == bytes:
        errorMsg = errorMsg.decode(encoding=appEncoding, errors="replace")
    try:
        with codecs.open(errorFile, mode="a", encoding=appEncoding) as fp:
            fp.write("\n[%s] %s\n" % (
                    time.strftime("%Y-%m-%d %H:%M:%S"), errorMsg))
    except:
        print("[wxpython.py] WARNING: failed writing to error file: %s" % (
                errorFile))
    # Convert error message to ascii before printing, otherwise
    # you may get error like this:
    # | UnicodeEncodeError: 'charmap' codec can't encode characters
    errorMsg = errorMsg.encode("ascii", errors="replace")
    errorMsg = errorMsg.decode("ascii", errors="replace")
    print("\n"+errorMsg+"\n")
    cefpython.QuitMessageLoop()
    cefpython.Shutdown()
    os._exit(1)

if __name__ == '__main__':

        sys.excepthook = ExceptHook

        # Application settings
        g_applicationSettings = {

            # These directories must be set on Linux
            "locales_dir_path": cefpython.GetModuleDirectory()+"/locales",
            "resources_dir_path": cefpython.GetModuleDirectory(),
            "browser_subprocess_path": "%s/%s" % (
                cefpython.GetModuleDirectory(), "subprocess"),
            "unique_request_context_per_browser": True,
            "downloads_enabled": True,
            "remote_debugging_port": 0,
            "context_menu": {
                "enabled": False,
                "navigation": False, # Back, Forward, Reload
                "print": False,
                "view_source": False,
                "external_browser": True, # Open in external browser
                "devtools": False, # Developer Tools
            },
            "ignore_certificate_errors": True,
        }

        g_browserSettings = {
            # "plugins_disabled": True,
            # "file_access_from_file_urls_allowed": True,
            # "universal_access_from_file_urls_allowed": True,
        }

        # Command line switches set programmatically
        g_commandLineSwitches = {
            # "proxy-server": "socks5://127.0.0.1:8888",
            # "no-proxy-server": "",
            # "enable-media-stream": "",
            # "disable-gpu": "",

        }

        cefpython.DpiAware.SetProcessDpiAware()

        cefpython.Initialize(g_applicationSettings, g_commandLineSwitches)

        app = WMS(False)
        app.MainLoop()

        # Let wx.App destructor do the cleanup before calling
        # cefpython.Shutdown(). This is to ensure reliable CEF shutdown.
        del app

        cefpython.Shutdown()
